# ==============================================================================
# Title: Supplementary Results
# Author: Leonardo Angeli
# Institution: University of Hasselt
# Date: 09/2024
# ==============================================================================

# Description:
# This script provides functions to calculate the Next Generation Matrix (NGM)
# and evaluate various epidemiological scenarios related to evolving contact
# patterns and susceptibilities across multiple waves of an infectious disease.
# The code produces results as presented in the Supplementary Information
# of the associated study.

# The script includes:
# 1. Calculation of the NGM for different transmission scenarios, 
#    such as static or evolving contact patterns and susceptibilities across
#    age groups.
# 2. Functions for evaluating specific epidemiological scenarios over a range 
#    of waves and age groups.
# 3. Sensitivity and elasticity analysis based on the NGM for each wave.
# 4. Plotting functions to visualize the results of the NGM analysis 
#    (e.g., Sensitivity, Elasticity, and Reproduction Number).

# Dependencies:
# This script relies on variables generated by the "wave_specific_an.R" script, 
# which sets up key parameters like:
# - `q_factor_sym`: Transmission factor for symptomatic cases.
# - `prop_ratio`: Proportion of asymptomatic transmission.
# - `A`: Age-specific mixing matrix.
# - `H`, `D_1_asym`, `D_2_sym`: Transmission parameters for different stages of infection.
# - `contact_sym_pc`, `contact_asym_pc`: Contact matrices for symptomatic and 
#    asymptomatic individuals across waves.

# Usage:
# To use the script, first ensure that all input variables (e.g., susceptibility 
# matrices, contact patterns, and wave dates) are defined in the global environment.
# Then call the appropriate functions to evaluate and analyze the scenarios 
# of interest. For example:
#   result <- evaluate_scenario(range = 1:10, bas_index = 1, scenario_func = static_susceptibles, ...)
#
# The code outputs results including the NGM, reproduction number (Rt), 
# sensitivity matrices, and elasticity matrices for each scenario.
#
# Note:
# This script is prepared for peer review, and further optimization and 
# refactoring may be considered for integration into the final analysis pipeline.
#
# ==============================================================================

# Function for Next Generation Matrix (NGM) analysis, evaluates a specific wave scenario
# Uses variables from the global environment (generated by "wave_specific_an.R")
NGM_analysis <- function(w_b, Susc_n, C_sym, C_asym) {
  # Define necessary variables for symptomatic and asymptomatic transmission
  q_sym <- q_factor_sym[[w_b]]  # Symptomatic transmission factor for the wave
  q_asym <- prop_ratio * q_sym   # Asymptomatic transmission factor
  
  # Initialize matrices for transmission and the Next Generation Matrix (NGM)
  Beta_sym <- matrix()
  Beta_asym <- matrix()
  K_1 <- matrix()
  
  # Calculate transmission matrices for symptomatic and asymptomatic cases
  Beta_sym <- diag(Susc_n) %*% A %*% C_sym %*% (q_sym * H)
  Beta_asym <- diag(Susc_n) %*% A %*% C_asym %*% (q_asym * H)
  
  # Compute NGM (combining symptomatic and asymptomatic transmissions)
  K_1 <- Beta_asym %*% D_1_asym + Beta_sym %*% D_2_sym
  
  # Calculate the effective reproduction number (R_t)
  R_t <- max(Re(eigen(K_1)$values))
  
  # Calculate sensitivity and elasticity
  S <- calc.sens(K_1)
  E <- calc.el(K_1)
  
  return(list(Rt = R_t, NGM = K_1, Sens = S, El = E))
}


# Function to evaluate a range of waves using a given scenario
evaluate_scenario <- function(range, bas_index, scenario_func, ...) {
  results <- list()
  iter <- 1
  for (wave in range) {
    n_wave <- wave - 8  # Adjust wave index if necessary
    # Apply the selected scenario function and store the result
    results[[iter]] <- c(Wave = wave, scenario_func(n_wave, bas_index, ...))
    iter <- iter + 1
  }
  return(results)
}


# Scenario 1: Evolving contact patterns with static susceptibles for all age groups
static_susceptibles <- function(n_wave, bas_index, susceptibles, contact_sym_pc, contact_asym_pc) {
  return(NGM_analysis(n_wave, Susc_n = susceptibles[[bas_index]], C_sym = contact_sym_pc[[n_wave]], C_asym = contact_asym_pc[[n_wave]]))
}


# Scenario 2: Static susceptibles for a specific age group with evolving contact patterns
static_susceptibles_age_group <- function(n_wave, bas_index, susceptibles, contact_sym_pc, contact_asym_pc, age, age_ints) {
  group <- which(age_ints %in% age)  # Identify the age group of interest
  baseline_susc <- susceptibles[[bas_index]][group]  # Baseline susceptibility for the group
  current_susc <- susceptibles[[n_wave]]
  current_susc[group] <- baseline_susc  # Keep baseline susceptibility for the selected age group
  
  return(NGM_analysis(n_wave, Susc_n = current_susc, C_sym = contact_sym_pc[[n_wave]], C_asym = contact_asym_pc[[n_wave]]))
}


# Scenario 3: Static contact patterns with evolving susceptibilities for all age groups
static_contact_pattern <- function(n_wave, bas_index, susceptibles, contact_sym_pc, contact_asym_pc) {
  return(NGM_analysis(n_wave, Susc_n = susceptibles[[n_wave]], C_sym = contact_sym_pc[[bas_index]], C_asym = contact_asym_pc[[bas_index]]))
}


# Scenario 4: Static contact patterns for a specific age group with evolving susceptibilities
static_contact_pattern_age_group <- function(n_wave, bas_index, susceptibles, contact_sym_pc, contact_asym_pc, age, age_ints, static_susc = c("all", "groups"), sel_contacts = c('contacting', 'contacted', 'both')) {
  group <- which(age_ints %in% age)  # Identify the age group of interest
  baseline_cont_sym <- contact_sym_pc[[bas_index]]  # Baseline symptomatic contact pattern
  baseline_cont_asym <- contact_asym_pc[[bas_index]]  # Baseline asymptomatic contact pattern
  current_cont_sym <- contact_sym_pc[[n_wave]]
  current_cont_asym <- contact_asym_pc[[n_wave]]
  
  # Adjust contact patterns based on the selected contact direction
  if (length(sel_contacts) > 1) sel_contacts <- "both"
  if (sel_contacts == 'contacting') {
    current_cont_sym[group, ] <- baseline_cont_sym[group, ]
    current_cont_asym[group, ] <- baseline_cont_asym[group, ]
  } else if (sel_contacts == 'contacted') {
    current_cont_sym[, group] <- baseline_cont_sym[, group]
    current_cont_asym[, group] <- baseline_cont_asym[, group]
  } else if (sel_contacts == 'both') {
    current_cont_sym[group, ] <- baseline_cont_sym[group, ]
    current_cont_asym[group, ] <- baseline_cont_asym[group, ]
    current_cont_sym[, group] <- baseline_cont_sym[, group]
    current_cont_asym[, group] <- baseline_cont_asym[, group]
  }
  
  # Handle static susceptibility if necessary
  baseline_susc <- susceptibles[[bas_index]]
  current_susc <- susceptibles[[n_wave]]
  if (length(static_susc) > 1) static_susc <- "all"
  if (static_susc == "groups") {
    susc <- baseline_susc
    susc[group] <- current_susc[group]
  } else {
    susc <- current_susc
  }
  
  return(NGM_analysis(n_wave, Susc_n = susc, C_sym = current_cont_sym, C_asym = current_cont_asym))
}


# Scenario 5: Modified contact pattern with proportional variation for a specific age group
modified_contact_pattern <- function(n_wave, bas_index, susceptibles, contact_sym_pc, contact_asym_pc, age, age_ints, prop) {
  group <- which(age_ints %in% age)  # Identify the age group of interest
  baseline_cont_sym <- contact_sym_pc[[bas_index]]
  baseline_cont_asym <- contact_asym_pc[[bas_index]]
  
  # Apply proportional variation to the contact patterns for the selected age group
  baseline_cont_sym[, group] <- baseline_cont_sym[, group] * (1 + prop * (!n_wave == bas_index))
  baseline_cont_asym[, group] <- baseline_cont_asym[, group] * (1 + prop * (!n_wave == bas_index))
  
  return(NGM_analysis(n_wave, Susc_n = susceptibles[[bas_index]], C_sym = baseline_cont_sym, C_asym = baseline_cont_asym))
}


# Function to select and evaluate a scenario based on a flag
select_scenario <- function(scenario_flag, range, bas_index, susceptibles, contact_sym_pc, contact_asym_pc, age, age_ints, contact_dir) {
  switch(scenario_flag,
         # Scenario 1: Evolving contact pattern with static susceptibles for a specific age group
         `1` = evaluate_scenario(range = range, bas_index = bas_index, scenario_func = static_susceptibles_age_group, susceptibles = susceptibles, contact_sym_pc = contact_sym_pc, contact_asym_pc = contact_asym_pc, age = age, age_ints = age_ints),
         # Scenario 2: Static contact pattern with evolving susceptibilities for a specific age group
         `2` = evaluate_scenario(range = range, bas_index = bas_index, scenario_func = static_contact_pattern_age_group, susceptibles = susceptibles, contact_sym_pc = contact_sym_pc, contact_asym_pc = contact_asym_pc, age = age, age_ints = age_ints, sel_contacts = contact_dir),
         # Scenario 3: Evolving contact pattern with static susceptibles for all age groups
         `3` = evaluate_scenario(range = range, bas_index = bas_index, scenario_func = static_susceptibles, susceptibles = susceptibles, contact_sym_pc = contact_sym_pc, contact_asym_pc = contact_asym_pc),
         # Scenario 4: Static contact pattern with evolving susceptibilities for all age groups
         `4` = evaluate_scenario(range = range, bas_index = bas_index, scenario_func = static_contact_pattern, susceptibles = susceptibles, contact_sym_pc = contact_sym_pc, contact_asym_pc = contact_asym_pc),
         # Error handling for invalid scenario flag
         stop("Invalid scenario flag")
  )
}

# Function to prepare the data for plotting
prepare_plotting <- function(sens_evo_list, age_breaks, w_dates, age_names, range_w) {
  # Initialize an empty data frame for the analysis
  c_analysis <- data.frame(
    Wave = integer(),
    Date = as.Date(character()),
    Age = character(),
    Sens = double(),
    Sens_standard = double(),
    Inf_val = double(),
    El = double(),
    Rt_mod = double(),
    stringsAsFactors = FALSE
  )
  
  # Loop through sensitivity evolution list and age groups
  for (i in seq_along(sens_evo_list)) {
    for (k in seq_along(age_breaks)) {
      # Create a new record with sensitivity and elasticity values
      new_record <- list(
        sens_evo_list[[i]]$Wave,  # The wave number
        w_dates[range_w[i]],      # Corresponding date for the wave
        age_names[k],             # Age group
        colSums(sens_evo_list[[i]]$Sens)[k],  # Sensitivity summed over all columns for the age group
        colSums(sens_evo_list[[i]]$Sens)[k] / sum(sens_evo_list[[i]]$Sens),  # Standardized sensitivity
        rowSums(sens_evo_list[[i]]$Sens)[k],  # Influence values (row sums)
        colSums(sens_evo_list[[i]]$El)[k],    # Elasticity summed over all columns for the age group
        sens_evo_list[[i]]$Rt                 # Reproduction number (Rt)
      )
      c_analysis[nrow(c_analysis) + 1, ] <- new_record  # Append the record to the data frame
    }
  }
  return(c_analysis)  # Return the complete analysis data frame
}


# Function to generate and save plots
generate_plot <- function(c_analysis, attribute, range, w_dates, age, age_names, file_name, variant, extra_variant = F, title_lab, highlight = F,
                          width, height, dpi, size_text) {
  
  # Calculate scaling factor for the attribute
  scaling_factor <- max(c_analysis[[attribute]]) * 1.5
  c_analysis$Age <- factor(c_analysis$Age, levels = age_names)
  
  # Set the Y-axis label based on the attribute being plotted
  switch(attribute,
         "El" = {label_y <- "Elasticity"},
         "Sens" = {label_y <- "Sensitivity"},
         "Inf_val" = {label_y <- "Inf. value"},
         stop("Invalid attribute")
  )
  
  # Define parameters for highlighting variants (e.g., Alpha, Delta)
  voc_bar_prop <- scaling_factor / 16
  y_min_voc <- -voc_bar_prop
  y_max_voc <- voc_bar_prop
  x_text_voc <- w_dates[range[length(range)]] - ((w_dates[range[length(range)]] - w_dates[range[1]]) / 2)
  y_text_voc <- 0
  
  # Adjust variant bars based on attribute being plotted
  if (attribute == "El") {
    y_min_voc <- -2 * voc_bar_prop
    y_max_voc <- 0
    y_text_voc <- -voc_bar_prop
  }
  
  # Determine the color for the variant (e.g., Wild Type, Alpha, Delta, Omicron)
  voc_color <- 1 * (variant == "Wild Type") + 2 * (variant == "Alpha") + 3 * (variant == "Delta") + 4 * (variant == "Omicron")
  
  # Determine maximum Y-axis value
  max_rt <- ifelse(is.null(c_analysis$Rt_mod), 0, max(c_analysis$Rt_mod * scaling_factor))
  max_y <- max(c_analysis[[attribute]], max_rt, na.rm = TRUE) * 1.1
  
  # Start building the plot
  plot <- ggplot()
  
  # Highlight age groups if needed
  if (highlight) {
    plot <- plot +
      geom_line(data = c_analysis %>% filter(Age %in% age), aes_string(x = "Date", y = attribute, color = "Age"), lwd = 5) +
      scale_color_manual("Age group", values = col_blind_pal[which(age_names %in% age)], labels = age_names[which(age_names %in% age)]) +
      geom_line(data = pert_df %>% filter(Age %in% age), aes_string(x = "Date", y = attribute, color = "Age"), lwd = 3.4, linetype = "longdash")
  } else {
    plot <- plot +
      geom_line(data = c_analysis %>% filter(Wave %in% range), aes_string(x = "Date", y = attribute, color = "Age"), lwd = 3) +
      scale_color_manual("Age group", values = col_blind_pal, labels = age_names)
  }
  
  # Add additional elements to the plot (lines, annotations, etc.)
  plot <- plot +
    geom_line(data = rep_df %>% filter(Wave %in% range), aes(x = Date, y = R0 * scaling_factor, linetype = "Rt"), lwd = 3.5) +
    geom_hline(yintercept = 1 * scaling_factor, lwd = 2) +
    geom_hline(aes(yintercept = mean(mean_df[[attribute]]), linetype = "Avg. value"), lwd = 2.8) +
    scale_x_date(breaks = w_dates[range], limits = c(w_dates[range[1]], w_dates[range[length(range)]]), expand = c(0, 0), sec.axis = sec_axis(~ ., breaks = w_dates[range], labels = range, name = "CoMix Wave")) +
    scale_linetype_manual(values = c("Rt" = "solid", "Avg. value" = "dashed")) +
    scale_y_continuous(expand = c(0, 0), limits = c(y_min_voc, max_y), sec.axis = sec_axis(~ . / scaling_factor, breaks = seq(0, 1.5, by = 0.5))) +
    guides(color = guide_legend(order = 1, override.aes = list(size = 25)), linetype = guide_legend(order = 2)) +
    theme_bw(base_size = base_size) +
    theme(plot.margin = plot.margin, title = element_text(family = fam, size = size_text), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.border = element_blank(), panel.background = element_blank(), legend.spacing.y = unit(1, 'cm'),
          axis.text.x.bottom = element_text(size = size_text, angle = 55, vjust = 0.5, family = fam), axis.text.x = element_text(size = size_text, angle = 75, vjust = 0.5, family = fam),
          axis.text.y = element_text(size = size_text, family = fam), legend.title = element_text(size = size_text * 1.1, family = fam),
          legend.text = element_text(size = size_text * 1.1, family = fam), legend.key.size = legend.key.size, legend.key.height = legend.key.height, legend.key.width = legend.key.width,
          axis.title.y.left = element_text(size = size_text * 1.2, family = fam), axis.title.x.top = element_text(size = size_text * 1.05, vjust = 0.5, family = fam),
          axis.text.x.top = element_text(size = size_text, vjust = 0.5, angle = 0, family = fam)) +
    labs(title = paste0("SCENARIO ", title_lab), y = label_y, x = "", linetype = '', color = 'Age group', shape = '')
  
  # Highlight variants if extra_variant is TRUE
  if (!extra_variant) {
    plot <- plot +
      annotate("rect", fill = pal[voc_color], alpha = 1, xmin = w_dates[range[1]], xmax = w_dates[range[length(range)]], ymin = y_min_voc, ymax = y_max_voc) +
      annotate("text", x = x_text_voc, y = y_text_voc, label = variant, size = annotations_size, family = fam)
  } else {
    variants <- c("Wild Type", "Alpha", "Delta", "Omicron")
    x_max <- df_vocs$Date_start[voc_color + 1]
    x_text_voc_2 <- x_max + round((w_dates[range[length(range)]] - x_max) / 2)
    plot <- plot +
      annotate("rect", fill = pal[voc_color], alpha = 1, xmin = w_dates[range[1]], xmax = x_max, ymin = y_min_voc, ymax = y_max_voc) +
      annotate("text", x = x_text_voc, y = y_text_voc, label = variant, size = annotations_size, family = fam) +
      annotate("rect", fill = pal[voc_color + 1], alpha = 1, xmin = x_max, xmax = w_dates[range[length(range)]], ymin = y_min_voc, ymax = y_max_voc) +
      annotate("text", x = x_text_voc_2, y = y_text_voc, label = variants[which(variants == variant) + 1], size = annotations_size, family = fam)
  }
  
  # Include Rt_mod points if present
  if (!is.null(c_analysis$Rt_mod)) {
    plot <- plot +
      geom_point(data = c_analysis %>% filter(Wave %in% range), aes(x = Date, y = Rt_mod * scaling_factor, shape = "Rt_mod"), color = "red", size = 18, stroke = 4, show.legend = F) +
      scale_shape_manual(values = c("Rt_mod" = 8)) +
      guides(shape = guide_legend(order = 3, override.aes = list(color = "red", size = 10))) +
      labs(shape = '')
  }
  
  # Save the plot to file
  ggsave(file_name, plot = plot, width = width, height = height, dpi = dpi, limitsize = F)
}


# Function to calculate second-order sensitivities
# The array returned is a matrix whose (l,m) entry is the derivative of s_ij w.r.t. k_lm (entries of the NGM)
sens2 <- function(A = matrix(), i, j) {
  eig <- eigen(A)  # Eigen decomposition of A
  lmax <- Re(eig$values[1])  # Largest eigenvalue (dominant eigenvalue)
  dim <- ncol(A)
  right_evs <- eig$vectors
  left_evs <- eigen(t(A))$vectors
  
  S <- calc.sens(A)  # First-order sensitivity
  S2 <- matrix(0, dim, dim)  # Initialize second-order sensitivity matrix
  E2 <- matrix(0, dim, dim)  # Initialize second-order elasticity matrix
  
  for (l in 1:dim) {
    for (m in 1:dim) {
      sum1 <- 0
      sum2 <- 0
      for (n in 2:dim) {
        sum1 <- sum1 + (Conj(left_evs[l, n])) * right_evs[j, n] / (lmax - Re(eig$values[n]))
        sum2 <- sum2 + (Conj(left_evs[i, n])) * right_evs[m, n] / (lmax - Re(eig$values[n]))
      }
      S2[l, m] <- sum1 * S[i, m] + sum2 * S[l, j]
      E2[l, m] <- S2[l, m] * A[i, j] / lmax - S[i, j] * S[l, m] * A[i, j] / (lmax^2) + (i == l) * (j == m) * S[i, j] / lmax
    }
  }
  
  return(list(sens = S2, el = E2))  # Return second-order sensitivity and elasticity
}


# Function to calculate gradients of sensitivity and elasticity
gradient_sens <- function(A, j, m, col = T) {
  grad_sens <- c()
  grad_el <- c()
  grad_inf <- c()
  
  # Loop through the matrix to calculate gradients
  for (l in seq_len(nrow(A))) {
    sum_sens <- 0
    sum_el <- 0
    sum_inf <- 0
    
    for (i in seq_len(nrow(A))) {
      sum_sens <- sum_sens + (sens2(A = A, i = i, j = j)$sens[l, m] * col + sens2(A = A, i = i, j = j)$sens[m, l] * (!col))
      sum_el <- sum_el + (sens2(A = A, i = i, j = j)$el[l, m] * col + sens2(A = A, i = i, j = j)$el[m, l] * (!col))
      sum_inf <- sum_inf + (sens2(A = A, i = j, j = i)$sens[l, m] * col + sens2(A = A, i = j, j = i)$sens[m, l] * (!col))
    }
    
    grad_sens[l] <- sum_sens
    grad_el[l] <- sum_el
    grad_inf[l] <- sum_inf
  }
  
  return(list(sens = grad_sens, el = grad_el, inf = grad_inf))  # Return gradients of sensitivity, elasticity, and influence
}

